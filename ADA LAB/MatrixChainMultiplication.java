import java.util.Arrays;

/**
 * Solves the Matrix Chain Multiplication problem using dynamic programming.
 */
public class MatrixChainMultiplication {

    // A record to hold the results conveniently
    public record McResult(int minCost, int[][] splitMatrix) {}

    /**
     * Calculates the minimum number of scalar multiplications needed to compute the
     * product of a chain of matrices.
     *
     * @param dims An array where dims[i] and dims[i+1] are the dimensions of the i-th matrix.
     * For n matrices, the array should have a length of n+1.
     * @return A McResult object containing the minimum cost and the split matrix.
     */
    public static McResult findMinCost(int[] dims) {
        // The number of matrices is one less than the length of the dimensions array.
        int n = dims.length - 1;
        if (n <= 1) {
            // If there's 0 or 1 matrix, the cost is 0.
            return new McResult(0, new int[n][n]);
        }

        // M[i][j] = Minimum number of multiplications to compute matrix A[i..j]
        // where i and j are 0-indexed.
        int[][] costMatrix = new int[n][n];

        // P[i][j] = Optimal split point (k) in the subproblem A[i..j].
        int[][] splitMatrix = new int[n][n];

        // The cost is 0 for multiplying a single matrix (the main diagonal).
        // This is already done by default Java array initialization, but shown for clarity.
        for (int i = 0; i < n; i++) {
            costMatrix[i][i] = 0;
        }

        // 'diag' is the chain length minus one.
        // We compute costs for chains of length 2, 3, ..., n.
        for (int diag = 1; diag < n; diag++) {
            // 'i' is the starting matrix index (0-based)
            for (int i = 0; i < n - diag; i++) {
                // 'j' is the ending matrix index
                int j = i + diag;
                
                // Initialize the cost for this subproblem to a very large value.
                costMatrix[i][j] = Integer.MAX_VALUE;

                // 'k' is the split point. We are calculating the cost of (A[i]...A[k]) * (A[k+1]...A[j])
                for (int k = i; k < j; k++) {
                    // Cost = cost(A[i..k]) + cost(A[k+1..j]) + cost(multiply results)
                    // The dimensions of the resulting matrices are:
                    // (A[i..k]) -> dims[i] x dims[k+1]
                    // (A[k+1..j]) -> dims[k+1] x dims[j+1]
                    int currentCost = costMatrix[i][k] + costMatrix[k+1][j] + dims[i] * dims[k+1] * dims[j+1];
                    
                    if (currentCost < costMatrix[i][j]) {
                        costMatrix[i][j] = currentCost;
                        splitMatrix[i][j] = k; // Store the best split point
                    }
                }
            }
        }

        // The final result is the minimum cost for the entire chain (from matrix 0 to n-1)
        return new McResult(costMatrix[0][n - 1], splitMatrix);
    }

    /**
     * Prints the optimal parenthesization for matrix multiplication.
     *
     * @param s The split matrix generated by findMinCost.
     * @param i The starting matrix index.
     * @param j The ending matrix index.
     */
    public static void printOptimalParenthesization(int[][] s, int i, int j) {
        if (i == j) {
            System.out.print("A" + i);
        } else {
            System.out.print("(");
            // Recursively print the left and right sub-expressions
            printOptimalParenthesization(s, i, s[i][j]);
            printOptimalParenthesization(s, s[i][j] + 1, j);
            System.out.print(")");
        }
    }

    public static void main(String[] args) {
        // Example: Three matrices A0, A1, A2 with dimensions
        // A0: 10x30
        // A1: 30x5
        // A2: 5x60
        int[] dimensions = {10, 30, 5, 60};
        int n = dimensions.length - 1; // Number of matrices

        System.out.println("Matrix dimensions array: " + Arrays.toString(dimensions));
        System.out.println("Number of matrices: " + n);
        
        McResult result = findMinCost(dimensions);

        System.out.println("Minimum number of scalar multiplications: " + result.minCost());

        System.out.print("Optimal Parenthesization: ");
        printOptimalParenthesization(result.splitMatrix(), 0, n - 1);
        System.out.println();
    }
}
